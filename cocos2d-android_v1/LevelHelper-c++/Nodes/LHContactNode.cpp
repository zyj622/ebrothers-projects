//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHContactNode.h"
#import "LevelHelperLoader.h"
#import "LHSettings.h"

class LHContactNodeInfo : public CCObject
{
	int tagB;
    SelectorProtocol* listenerId;
    SEL_CallFuncO listenerSel;  
public:
    LHContactNodeInfo(){}

    virtual ~LHContactNodeInfo(void){CCLog("ContactNodeInfo release");}
    
    bool initcontactInfoWithTag(int _tagB,
                                SelectorProtocol* listId,
                                SEL_CallFuncO  listSel){
        tagB = _tagB;
        listenerId = listId;
        listenerSel = listSel;
        return true;
    }
    
    static LHContactNodeInfo* contactInfoWithTag(int tagB,
                                                SelectorProtocol* listId,
                                                SEL_CallFuncO  listSel){
       LHContactNodeInfo *pobInfo = new LHContactNodeInfo();
       if (pobInfo && pobInfo->initcontactInfoWithTag(tagB, listId, listSel))
       {
           pobInfo->autorelease();
           return pobInfo;
       }
       CC_SAFE_DELETE(pobInfo);
       return NULL;
       
   }
    
    int getTagB(){return tagB;}
    
    void callListenerWithBodyA(b2Body* A, 
                               b2Body* B,
                               b2Contact* contact,
                               const b2Manifold* oldManifold,
                               const b2ContactImpulse* impulse){
        
        
        LHContactInfo* info = LHContactInfo::contactInfo(A, B, contact, oldManifold, impulse); 
        
        if (listenerId) {
            (listenerId->*listenerSel)(info);
        }
    }

};
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void lhContact_CallPreSolveMethod(void* object, 
                                  b2Contact* contact, 
                                  const b2Manifold* oldManifold)
{
    ((LHContactNode*)object)->preSolve(contact, oldManifold);
}
////////////////////////////////////////////////////////////////////////////////
void lhContact_CallPostSolveMethod(void* object, 
                                   b2Contact* contact, 
                                   const b2ContactImpulse* impulse)
{
    ((LHContactNode*)object)->postSolve(contact, impulse);
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
LHContactNode::LHContactNode(){
    
}
LHContactNode::~LHContactNode(){

    CCLog("LHContactNode release");
    
    std::vector<int> allPreKeys = preCollisionMap.allKeys();    
    for(size_t i = 0; i < allPreKeys.size(); ++i)
    {
        CCMutableDictionary<int>* tableA = (CCMutableDictionary<int>*)preCollisionMap.objectForKey(allPreKeys[i]);
        delete tableA;
    }

    std::vector<int> allPostKeys = postCollisionMap.allKeys();    
    for(size_t i = 0; i < allPostKeys.size(); ++i)
    {
        CCMutableDictionary<int>* tableA = (CCMutableDictionary<int>*)postCollisionMap.objectForKey(allPostKeys[i]);
        delete tableA;
    }
    
    preCollisionMap.removeAllObjects();
    postCollisionMap.removeAllObjects();
    delete lhContactListener;
}
////////////////////////////////////////////////////////////////////////////////
bool LHContactNode::initContactNodeWithWorld(b2World* world){

    if(0 == world)
        return false;

    lhContactListener = new LHContactListener();
    world->SetContactListener(lhContactListener);
    
    lhContactListener->nodeObject = this;
    lhContactListener->preSolveSelector = &lhContact_CallPreSolveMethod;
    lhContactListener->postSolveSelector = &lhContact_CallPostSolveMethod;

    return true;
}
LHContactNode* LHContactNode::contactNodeWithWorld(b2World* world){
    
    LHContactNode *pobNode = new LHContactNode();
    if (pobNode && pobNode->initContactNodeWithWorld(world))
    {
        pobNode->autorelease();
        return pobNode;
    }
    CC_SAFE_DELETE(pobNode);
    return NULL;
}
////////////////////////////////////////////////////////////////////////////////
void LHContactNode::registerPreColisionCallbackBetweenTagA(int tagA, 
                                                           int tagB,
                                                           SelectorProtocol* obj, 
                                                           SEL_CallFuncO sel)
{
    CCMutableDictionary<int>* tableA = (CCMutableDictionary<int>*)preCollisionMap.objectForKey(tagA);
    
    
    if(tableA == NULL){
        LHContactNodeInfo* info = LHContactNodeInfo::contactInfoWithTag(tagB, obj, sel);
        
        CCMutableDictionary<int>* map = new CCMutableDictionary<int>();
        map->setObject(info, tagB);
        preCollisionMap.setObject(map, tagA);
    }
    else{
        LHContactNodeInfo* info = LHContactNodeInfo::contactInfoWithTag(tagB, obj, sel);
        tableA->setObject(info, tagB);
    }   
}
////////////////////////////////////////////////////////////////////////////////
void LHContactNode::cancelPreColisionCallbackBetweenTagA(int tagA,
                                                         int tagB){
    CCMutableDictionary<int>* tableA = (CCMutableDictionary<int>*)preCollisionMap.objectForKey(tagA);

    if(NULL != tableA)
    {
        tableA->removeObjectForKey(tagB);
    }
}
////////////////////////////////////////////////////////////////////////////////
void LHContactNode::registerPostColisionCallbackBetweenTagA(int tagA,
                                                            int tagB,
                                                            SelectorProtocol* obj, 
                                                            SEL_CallFuncO sel)
{
    
    CCMutableDictionary<int>* tableA = (CCMutableDictionary<int>*)postCollisionMap.objectForKey(tagA);
    
    
    if(tableA == NULL){
        LHContactNodeInfo* info = LHContactNodeInfo::contactInfoWithTag(tagB, obj, sel);
        
        CCMutableDictionary<int>* map = new CCMutableDictionary<int>();
        map->setObject(info, tagB);
        postCollisionMap.setObject(map, tagA);
    }
    else{
        LHContactNodeInfo* info = LHContactNodeInfo::contactInfoWithTag(tagB, obj, sel);
        tableA->setObject(info, tagB);
    }   
}
////////////////////////////////////////////////////////////////////////////////
void LHContactNode::cancelPostColisionCallbackBetweenTagA(int tagA,
                                                          int tagB)
{
    CCMutableDictionary<int>* tableA = (CCMutableDictionary<int>*)postCollisionMap.objectForKey(tagA);
    
    if(NULL != tableA)
    {
        tableA->removeObjectForKey(tagB);
    }
}
////////////////////////////////////////////////////////////////////////////////
void LHContactNode::preSolve(b2Contact* contact,                     
                             const b2Manifold* oldManifold)
{
    b2Body *bodyA = contact->GetFixtureA()->GetBody();
	b2Body *bodyB = contact->GetFixtureB()->GetBody();
	
    
    CCNode* nodeA = (CCNode*)bodyA->GetUserData();
    CCNode* nodeB = (CCNode*)bodyB->GetUserData();
        
    CCMutableDictionary<int>* info = (CCMutableDictionary<int>*)preCollisionMap.objectForKey(nodeA->getTag());
    
    if(info != NULL){

        LHContactNodeInfo* contactInfo = (LHContactNodeInfo*)info->objectForKey(nodeB->getTag());
        
        if(NULL != contactInfo)
        {
            contactInfo->callListenerWithBodyA(bodyA,bodyB,contact,oldManifold,0);
        }
    }
    else
    {
        info = (CCMutableDictionary<int>*)preCollisionMap.objectForKey(nodeB->getTag());
        
        if(NULL != info){
            
            LHContactNodeInfo* contactInfo = (LHContactNodeInfo*)info->objectForKey(nodeA->getTag());
            
            if(NULL != contactInfo)
            {
                contactInfo->callListenerWithBodyA(bodyB, bodyA, contact, oldManifold, 0);
            }
        }        
    }
}
////////////////////////////////////////////////////////////////////////////////
void LHContactNode::postSolve(b2Contact* contact,
                              const b2ContactImpulse* impulse){
    
    b2Body *bodyA = contact->GetFixtureA()->GetBody();
	b2Body *bodyB = contact->GetFixtureB()->GetBody();
	
    
    CCNode* nodeA = (CCNode*)bodyA->GetUserData();
    CCNode* nodeB = (CCNode*)bodyB->GetUserData();
    
    CCMutableDictionary<int>* info = (CCMutableDictionary<int>*)preCollisionMap.objectForKey(nodeA->getTag());
    
    if(info != NULL){
        
        LHContactNodeInfo* contactInfo = (LHContactNodeInfo*)info->objectForKey(nodeB->getTag());
        
        if(NULL != contactInfo)
        {
            contactInfo->callListenerWithBodyA(bodyA,bodyB,contact,0,impulse);
        }
    }
    else
    {
        info = (CCMutableDictionary<int>*)preCollisionMap.objectForKey(nodeB->getTag());
        
        if(NULL != info){
            
            LHContactNodeInfo* contactInfo = (LHContactNodeInfo*)info->objectForKey(nodeA->getTag());
            
            if(NULL != contactInfo)
            {
                contactInfo->callListenerWithBodyA(bodyB, bodyA, contact, 0, impulse);
            }
        }        
    }    
}
////////////////////////////////////////////////////////////////////////////////
