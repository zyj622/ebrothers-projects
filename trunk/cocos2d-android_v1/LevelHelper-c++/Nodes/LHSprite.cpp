//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#include "LHSprite.h"

#include "LHAnimationNode.h"
#include "LevelHelperLoader.h"
#include "LHPathNode.h"
#include "LHParallaxNode.h"
int LHSprite::numberOfSprites = 0;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
LHSprite::~LHSprite(void){

    if(NULL != parallaxFollowingThisSprite)
        parallaxFollowingThisSprite->setFollowSprite(NULL);

    CCLog("LHSPRITE Destructor %d", --numberOfSprites);
    stopAllActions();
       
    cancelPathMovement();
    
    if(NULL != parallaxNode)
        parallaxNode->removeChild(this);
    
    
    removeBodyFromWorld();
}
////////////////////////////////////////////////////////////////////////////////
bool LHSprite::init(void){

    CCLog("LHSprite init");
    body = NULL;
    currentFrame = 0;
    pathNode = NULL;
    parallaxNode = NULL;
    parallaxFollowingThisSprite = NULL;
    
    return CCSprite::init();
}
////////////////////////////////////////////////////////////////////////////////
LHSprite::LHSprite(){
    
    ++numberOfSprites;
    CCLog("LHSprite Constructor %d", numberOfSprites);
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setUniqueName(const char* name){
    uniqueName = std::string(name);
}
const std::string& LHSprite::getUniqueName(void){
    return uniqueName;
}
////////////////////////////////////////////////////////////////////////////////
void  LHSprite::setBody(b2Body* bd){
    CCAssert(bd!=0, "b2Body must not be nil");
    body = bd;
}
b2Body*  LHSprite::getBody(void){
    return body;
}
bool  LHSprite::removeBodyFromWorld(void){
    
    CCLog("remove body from world");
    if(NULL != body)
	{
		b2World* _world = body->GetWorld();
		if(0 != _world)
		{
			_world->DestroyBody(body);
			body = NULL;
            
            return true;
		}
	}
    
    return false;    
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setAnimation(LHAnimationNode* anim){
    animation = anim;

    if(0 != anim){
        anim->setAnimationTexturePropertiesOnSprite(this);
        setFrame(0);
    }
}
LHAnimationNode* LHSprite::getAnimation(void){
    return animation;
}
std::string LHSprite::getAnimationName(void){

    if(0 != animation)
        return animation->getUniqueName();
    
    return std::string("");
}
int LHSprite::getNumberOfFrames(void){

    if(0 != animation)
        return animation->getNumberOfFrames();
    return -1;
}
void LHSprite::setFrame(int frmNo){

    if(animation == 0)
        return;
    
    animation->setFrame(frmNo, this);
    currentFrame = frmNo;
}
int LHSprite::getCurrentFrame(void){
   
    if(0 != animation){
        CCMutableArray<CCSpriteFrame*> *frames = animation->getFrames();
        if(0 != frames)
        {
            for(int i = 0; i < (int)frames->count(); ++i){
                CCSpriteFrame* frame = (CCSpriteFrame*)frames->getObjectAtIndex(i);
                
                if(CCRect::CCRectEqualToRect(frame->getRect(), getTextureRect())){
                    return i;
                }
            }
        }
    }
    return 0;
}

void LHSprite::stopAnimation(){
    stopActionByTag(LH_ANIM_ACTION_TAG);
    setAnimation(NULL);
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setPathNode(LHPathNode* node){
    CCAssert(node != NULL, "Argument must not be null");
    pathNode = node;
}
LHPathNode* LHSprite::getPathNode(void){
    return pathNode;
}
void LHSprite::cancelPathMovement(void){
    if(NULL != pathNode){
        pathNode->removeFromParentAndCleanup(true);
        pathNode = NULL;
    }
}
void LHSprite::pausePathMovement(const bool& pauseStatus){
    if(NULL != pathNode){
        pathNode->setPaused(pauseStatus);
    }
}
void LHSprite::registerNotifierOnPathEndPoints(SelectorProtocol* obj, 
                                               SEL_CallFuncN sel)
{    
    if(NULL == pathNode)
        return;
    
    pathNode->setPathNotifierObject(obj);
    pathNode->setPathNotifierSelector(sel);   
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setCustomValue(void* value, const char* key){
    CCAssert(value!=0, "Custom value object must not be nil");    
    CCAssert(key!=0, "Custom value key must not be nil");    
    
    customUserValues[std::string(key)] = value;
}
void* LHSprite::getCustomValueWithKey(const char* key){
    CCAssert(key!=0, "Custom value key must not be nil");    
    return customUserValues[std::string(key)];
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::transformPosition(CCPoint pos){
    setPosition(pos);
    if(0 != body)
    {
        b2Vec2 boxPosition = LevelHelperLoader::pointsToMeters(pos);
        float angle = CC_DEGREES_TO_RADIANS(-1*getRotation());
        body->SetTransform(boxPosition, angle);
    }
}
void LHSprite::transformRotation(float rot){
    setRotation(rot);
    if(0 != body)
    {
        b2Vec2 boxPosition = LevelHelperLoader::pointsToMeters(getPosition());
        float angle = CC_DEGREES_TO_RADIANS(-1*rot);
        body->SetTransform(boxPosition, angle);
    }    
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
LHSprite* LHSprite::sprite(void){
    LHSprite *pobSprite = new LHSprite();
	if (pobSprite && pobSprite->init())
    {
	    pobSprite->autorelease();
        return pobSprite;
    }
    CC_SAFE_DELETE(pobSprite);
	return NULL;
}
LHSprite* LHSprite::spriteWithTexture(CCTexture2D *pTexture)
{
	LHSprite *pobSprite = new LHSprite();
	if (pobSprite && pobSprite->initWithTexture(pTexture))
    {
	    pobSprite->autorelease();
        return pobSprite;
    }
    CC_SAFE_DELETE(pobSprite);
	return NULL;
}

LHSprite* LHSprite::spriteWithTexture(CCTexture2D *pTexture, const CCRect& rect)
{
    LHSprite *pobSprite = new LHSprite();
	if (pobSprite && pobSprite->initWithTexture(pTexture, rect))
    {
	    pobSprite->autorelease();
        return pobSprite;
    }
    CC_SAFE_DELETE(pobSprite);
	return NULL;
}

LHSprite* LHSprite::spriteWithTexture(CCTexture2D *pTexture, const CCRect& rect, const CCPoint& offset)
{
    CC_UNUSED_PARAM(pTexture);
    CC_UNUSED_PARAM(rect);
    CC_UNUSED_PARAM(offset);
	// not implement
	CCAssert(0, "");
	return NULL;
}

LHSprite* LHSprite::spriteWithFile(const char *pszFileName)
{
    LHSprite *pobSprite = new LHSprite();
    if (pobSprite && pobSprite->initWithFile(pszFileName))
    {
        pobSprite->autorelease();
        return pobSprite;
    }
    CC_SAFE_DELETE(pobSprite);
	return NULL;
}

LHSprite* LHSprite::spriteWithFile(const char *pszFileName, const CCRect& rect)
{
    LHSprite *pobSprite = new LHSprite();
	if (pobSprite && pobSprite->initWithFile(pszFileName, rect))
    {
	    pobSprite->autorelease();
        return pobSprite;
    }
    CC_SAFE_DELETE(pobSprite);
	return NULL;
}

LHSprite* LHSprite::spriteWithSpriteFrame(CCSpriteFrame *pSpriteFrame)
{
    LHSprite *pobSprite = new LHSprite();
    if (pobSprite && pobSprite->initWithSpriteFrame(pSpriteFrame))
    {
	    pobSprite->autorelease();
        return pobSprite;
    }
    CC_SAFE_DELETE(pobSprite);
	return NULL;
}

LHSprite* LHSprite::spriteWithSpriteFrameName(const char *pszSpriteFrameName)
{
	CCSpriteFrame *pFrame = CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(pszSpriteFrameName);
    
    char msg[256] = {0};
    sprintf(msg, "Invalid spriteFrameName: %s", pszSpriteFrameName);
    CCAssert(pFrame != NULL, msg);
	return spriteWithSpriteFrame(pFrame);
}

LHSprite* LHSprite::spriteWithBatchNode(CCSpriteBatchNode *batchNode, const CCRect& rect)
{
	LHSprite *pobSprite = new LHSprite();
	if (pobSprite && pobSprite->initWithBatchNode(batchNode, rect))
	{
        pobSprite->autorelease();
        return pobSprite;
    }
    CC_SAFE_DELETE(pobSprite);
	return NULL;
}

